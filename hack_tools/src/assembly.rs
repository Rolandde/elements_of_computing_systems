//! Assembler that converts from `.asm` assembly format to `.hack` machine instructions format.

/// An iterator over the assembly labels and the commands they point to. 
/// 
/// Used to create the [SymbolTable] needed for the [SecondPass]
pub struct FirstPass<R> {
    inner: crate::assembly_io::Reader<R>,
    command_count: i16,
}

impl<R: std::io::BufRead> FirstPass<R> {
    pub fn new(buffer: R) -> Self {
        Self {
            inner: crate::assembly_io::Reader::new(buffer),
            command_count: 0,
        }
    }

    /// Consumes the iterator and converts it into [SymbolTable].
    /// 
    /// # Examples
    /// ```
    /// let rom = b"\\Comment\n(Label)\n\\Comment\n@1";
    /// let symbol_table = hack_tools::assembly::FirstPass::new(&rom[..]).collect_symbol_table()?;
    /// # Ok::<(), hack_tools::Error>(())
    /// ```
    pub fn collect_symbol_table(self) -> Result<SymbolTable, crate::Error> {
        let mut st = SymbolTable::new();

        for label in self {
            let LabelAddress {
                label,
                command_count,
                label_line,
            } = label?;
            if st.inner.contains_key(&label) {
                Err(crate::Error::SymbolTable(label_line))?
            }
            st.inner.insert(label, command_count.into());
        }

        Ok(st)
    }

    /// Read the next instruction.
    ///
    /// Returns the total number of lines read so far. 0 if EOF has been reached.
    ///
    /// # Examples
    /// ```
    /// let rom = b"\\Nothing\n@Yes\nNo";
    /// let mut reader = hack_tools::assembly::FirstPass::new(&rom[..]);
    /// assert_eq!(reader.read_instruction()?, 2);
    /// assert_eq!(reader.read_instruction()?, 3);
    /// assert_eq!(reader.read_instruction()?, 0);
    /// # Ok::<(), hack_tools::Error>(())
    /// ```
    pub fn read_instruction(&mut self) -> Result<i16, crate::Error> {
        let lines_read = self.inner.read_instruction()?;
        match self.inner.is_command() {
            Some(true) => self.command_count += 1,
            _ => {}
        }
        Ok(lines_read)
    }

    /// Get label and its associated address.
    ///
    /// This assumes the reader is at a label.
    ///
    /// # Examples
    /// ```
    /// let rom = b"\\Comment\n(Label)\n\\Comment\n@1";
    /// let mut first_pass = hack_tools::assembly::FirstPass::new(&rom[..]);
    /// first_pass.read_instruction()?;
    /// assert_eq!(
    ///     first_pass.get_label_address()?,
    ///     hack_tools::assembly::LabelAddress{
    ///         label: "Label".to_string(),
    ///         command_count: 1,
    ///         label_line: 2,
    ///     }
    /// );
    /// # Ok::<(), hack_tools::Error>(())
    /// ```
    pub fn get_label_address(&mut self) -> Result<LabelAddress, crate::Error> {
        let label_line = self.inner.line;
        let label = self
            .inner
            .parse_label()?
            .ok_or(crate::Error::AssemblyLabel(label_line))?;
        self.read_instruction()?;

        match self.inner.is_command() {
            Some(true) => Ok(LabelAddress {
                label,
                command_count: self.command_count,
                label_line,
            }),
            // Command does not follow a label
            Some(false) => Err(crate::Error::AssemblyLabel(label_line)),
            // End of file following label
            None => Err(crate::Error::AssemblyLabel(label_line)),
        }
    }
}

impl<R: std::io::BufRead> std::iter::Iterator for FirstPass<R> {
    type Item = Result<LabelAddress, crate::Error>;
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            match self.read_instruction() {
                Ok(_) => {}
                Err(e) => break Some(Err(e)),
            }
            match self.inner.is_label() {
                None => break None,
                Some(true) => break Some(self.get_label_address()),
                Some(false) => continue,
            }
        }
    }
}

/// Symbol table generated by the first pass through the assembly code.
///
/// Populated by [FirstPass]. If you are certain the assembly code does not use any custom symbols, this can be used directly with [SecondPass].
pub struct SymbolTable {
    inner: std::collections::HashMap<String, crate::Bit15>,
}

impl SymbolTable {
    pub fn new() -> Self {
        let mut h = std::collections::HashMap::new();
        h.insert("SP".to_string(), 0.into());
        h.insert("LCL".to_string(), 1.into());
        h.insert("ARG".to_string(), 2.into());
        h.insert("THIS".to_string(), 3.into());
        h.insert("THAT".to_string(), 4.into());
        h.insert("R0".to_string(), 0.into());
        h.insert("R1".to_string(), 1.into());
        h.insert("R2".to_string(), 2.into());
        h.insert("R3".to_string(), 3.into());
        h.insert("R4".to_string(), 4.into());
        h.insert("R5".to_string(), 5.into());
        h.insert("R6".to_string(), 6.into());
        h.insert("R7".to_string(), 7.into());
        h.insert("R8".to_string(), 8.into());
        h.insert("R9".to_string(), 9.into());
        h.insert("R10".to_string(), 10.into());
        h.insert("R11".to_string(), 11.into());
        h.insert("R12".to_string(), 12.into());
        h.insert("R13".to_string(), 13.into());
        h.insert("R14".to_string(), 14.into());
        h.insert("R15".to_string(), 15.into());
        h.insert("SCREEN".to_string(), 16385.into());
        h.insert("KBD".to_string(), 24576.into());
        Self { inner: h }
    }
}

/// Convenience container for a label that has been read
#[derive(Debug, PartialEq, Eq)]
pub struct LabelAddress {
    /// The label
    pub label: String,
    /// Counting only commands, which command line does the label refer to?
    pub command_count: i16,
    /// Total raw lines read to get to the label
    pub label_line: i16,
}

#[cfg(test)]
mod cpu_tests {
    use super::*;

    #[test]
    fn collect_symbol_table() -> Result<(), crate::Error> {
        let rom = b"\\Comment\n@0\n(Label)\n\\Comment\n@1";
        let symbol_table = FirstPass::new(&rom[..]).collect_symbol_table()?;
        assert_eq!(symbol_table.inner.get("Label"), Some(&2.into()));
        Ok(())
    }
}
